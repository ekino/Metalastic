/*
 * Copyright (c) 2025 ekino (https://www.ekino.com/)
 */

package com.ekino.oss.metalastic.processor.building

import com.ekino.oss.metalastic.processor.CoreConstants
import com.ekino.oss.metalastic.processor.CoreConstants.PRODUCT_NAME
import com.ekino.oss.metalastic.processor.model.MetalasticGraph
import com.ekino.oss.metalastic.processor.options.ProcessorOptions
import com.ekino.oss.metalastic.processor.report.reporter
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName

/**
 * MetamodelsBuilder - Pure Metamodels registry generation component.
 *
 * Responsibilities:
 * - Generate the Metamodels object with entries() function
 * - Handle Q-class naming conflicts with fully qualified names
 * - Apply proper Java interoperability annotations
 * - Generate type-safe sequence of Q-class instances
 * - Handle import optimization for conflicted vs non-conflicted classes
 */
class MetamodelsBuilder(val graph: MetalasticGraph, val options: ProcessorOptions) {

  fun buildMetamodelsRegistry(): FileSpec? {
    val documents: List<MetalasticGraph.DocumentClass> =
      graph.documentModels().toList().takeIf { it.isNotEmpty() } ?: return null

    reporter.debug { "Building Metamodels registry for ${documents.size} documents" }
    // Generate metamodels info from the document classes (need to extract KSClassDeclaration from
    // documents)
    val metamodelsInfo = options.metamodelsConfiguration.generateMetamodelsInfo(graph)

    val metamodelsClass =
      TypeSpec.objectBuilder(metamodelsInfo.className)
        .addGeneratedAnnotation()
        .addFunction(buildEntriesFunction(documents))
        .build()

    val fileSpecBuilder =
      FileSpec.builder(metamodelsInfo.packageName, metamodelsInfo.className)
        .addType(metamodelsClass)
        .addFileComment(
          "This file is automatically generated by $PRODUCT_NAME processor. Do not modify."
        )

    val fileSpec = fileSpecBuilder.build()

    reporter.debug { "Generated Metamodels with ${documents.size} Q-class entries" }
    return fileSpec
  }

  /**
   * Builds the entries() function that returns a sequence of all Q-class instances. Handles naming
   * conflicts by using fully qualified names for conflicted classes.
   */
  private fun buildEntriesFunction(documents: List<MetalasticGraph.DocumentClass>): FunSpec {
    val wildcardDocumentType =
      QClassGenerator.documentClass.parameterizedBy(com.squareup.kotlinpoet.STAR)
    val sequenceType = Sequence::class.asClassName().parameterizedBy(wildcardDocumentType)
    val entriesCode = buildEntriesCodeBlock(documents)

    return FunSpec.builder(CoreConstants.Metamodels.ENTRIES_FUNCTION_NAME)
      .addModifiers(KModifier.PUBLIC)
      .withOptionalJavaCompatibility()
      .returns(sequenceType)
      .addCode(entriesCode)
      .addKdoc("Returns a sequence of all generated metamodel instances.")
      .build()
  }

  /**
   * Builds the code block for the entries() function. Uses fully qualified names for conflicted
   * Q-classes, simple names for others.
   */
  private fun buildEntriesCodeBlock(documents: List<MetalasticGraph.DocumentClass>): CodeBlock {
    val codeBuilder = CodeBlock.builder()
    codeBuilder.add("return sequenceOf(\n")
    codeBuilder.indent()

    documents
      .sortedBy { it.qClassName }
      .forEach { document ->
        val companionAccess =
          ClassName("${document.fullyQualifiedName}.Companion", document.companionPropertyName)
        codeBuilder.add("%T,\n", companionAccess)
      }

    codeBuilder.unindent()
    codeBuilder.add(")")

    return codeBuilder.build()
  }

  private fun FunSpec.Builder.withOptionalJavaCompatibility() = apply {
    if (options.generateJavaCompatibility) {
      addAnnotation(AnnotationSpec.builder(JvmStatic::class).build())
    }
  }
}
