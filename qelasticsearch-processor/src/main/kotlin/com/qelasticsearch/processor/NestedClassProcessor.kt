package com.qelasticsearch.processor

import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toTypeParameterResolver
import org.springframework.data.annotation.Id
import org.springframework.data.elasticsearch.annotations.Document
import org.springframework.data.elasticsearch.annotations.Field
import org.springframework.data.elasticsearch.annotations.MultiField

/**
 * Handles processing of nested classes and object field registration.
 */
class NestedClassProcessor(
    private val logger: KSPLogger,
    private val codeGenUtils: CodeGenerationUtils,
) {
    private val globalObjectFields = mutableMapOf<String, ObjectFieldInfo>()

    /**
     * Collects all object fields from a document class.
     */
    fun collectObjectFields(
        documentClass: KSClassDeclaration,
        fieldTypeExtractor: FieldTypeExtractor,
    ) {
        processClassProperties(documentClass, fieldTypeExtractor) { nestedClass ->
            registerObjectField(nestedClass, documentClass)
            collectObjectFieldsFromClass(nestedClass, fieldTypeExtractor)
        }
    }

    /**
     * Collects all possible object fields from the entire classpath.
     */
    fun collectAllPossibleObjectFields(resolver: Resolver) {
        try {
            val allClasses = mutableListOf<KSClassDeclaration>()

            resolver.getAllFiles().flatMap { it.declarations }.forEach { declaration ->
                if (declaration is KSClassDeclaration && declaration.classKind == ClassKind.CLASS) {
                    allClasses.add(declaration)
                    collectNestedClasses(declaration, allClasses)
                }
            }

            val filteredClasses =
                allClasses.filter {
                    !codeGenUtils.isStandardLibraryType(it.packageName.asString())
                }

            logger.info("Scanning ${filteredClasses.size} classes for Elasticsearch annotations...")

            filteredClasses.forEach { classDeclaration ->
                val hasElasticsearchAnnotations = hasElasticsearchAnnotations(classDeclaration)
                val objectFieldKey = generateObjectFieldKey(classDeclaration)

                if (hasElasticsearchAnnotations && objectFieldKey !in globalObjectFields) {
                    registerObjectField(classDeclaration, null)
                }
            }

            logger.info("Total registered ObjectFields: ${globalObjectFields.size}")
        } catch (e: Exception) {
            logger.warn("Error collecting all possible object fields: ${e.message}")
        }
    }

    /**
     * Gets nested classes that should be included in a document Q-class.
     */
    fun getNestedClassesForDocument(documentClass: KSClassDeclaration): List<ObjectFieldInfo> =
        globalObjectFields.values.filter { objectFieldInfo ->
            objectFieldInfo.parentDocumentClass == documentClass
        }

    /**
     * Adds nested objects to a Q-class builder.
     */
    fun addNestedObjectsToBuilder(
        documentClass: KSClassDeclaration,
        parentObjectBuilder: TypeSpec.Builder,
        fieldGenerators: FieldGenerators,
        fieldTypeExtractor: FieldTypeExtractor,
        objectFieldRegistry: ObjectFieldRegistry,
    ) {
        val nestedClasses = getNestedClassesForDocument(documentClass)

        nestedClasses.forEach { objectFieldInfo ->
            val nestedObjectBuilder =
                createNestedObjectBuilder(
                    objectFieldInfo,
                    fieldGenerators,
                    fieldTypeExtractor,
                    objectFieldRegistry,
                )
            parentObjectBuilder.addType(nestedObjectBuilder.build())
        }
    }

    /**
     * Creates a TypeSpec.Builder for a nested object class.
     */
    private fun createNestedObjectBuilder(
        objectFieldInfo: ObjectFieldInfo,
        fieldGenerators: FieldGenerators,
        fieldTypeExtractor: FieldTypeExtractor,
        objectFieldRegistry: ObjectFieldRegistry,
    ): TypeSpec.Builder {
        val nestedClassName = objectFieldInfo.classDeclaration.simpleName.asString()

        val objectBuilder =
            TypeSpec
                .objectBuilder(nestedClassName)
                .addKdoc(
                    """
                    Query DSL object fields for nested class [${objectFieldInfo.qualifiedName}].
                    
                    This nested object was automatically generated by QElasticsearch annotation processor
                    from the source nested class [${objectFieldInfo.qualifiedName}].
                    
                    **Do not modify this object directly.** Any changes will be overwritten
                    during the next compilation. To modify the DSL structure, update the
                    annotations on the source nested class.
                    
                    @see ${objectFieldInfo.qualifiedName}
                    @generated by QElasticsearch annotation processor
                    """.trimIndent(),
                ).superclass(ClassName(DSLConstants.DSL_PACKAGE, DSLConstants.OBJECT_FIELDS_CLASS))

        addPropertiesFromClassToObjectBuilder(
            objectFieldInfo.classDeclaration,
            objectBuilder,
            fieldGenerators,
            fieldTypeExtractor,
            objectFieldRegistry,
        )

        return objectBuilder
    }

    /**
     * Adds properties from a class declaration to an object builder.
     */
    private fun addPropertiesFromClassToObjectBuilder(
        classDeclaration: KSClassDeclaration,
        objectBuilder: TypeSpec.Builder,
        fieldGenerators: FieldGenerators,
        fieldTypeExtractor: FieldTypeExtractor,
        objectFieldRegistry: ObjectFieldRegistry,
    ) {
        val importContext = ImportContext()
        val typeParameterResolver = classDeclaration.typeParameters.toTypeParameterResolver()

        processUniqueProperties(classDeclaration) { property ->
            fieldGenerators.processProperty(
                property,
                objectBuilder,
                importContext,
                typeParameterResolver,
                fieldTypeExtractor,
                objectFieldRegistry,
            )
        }

        // Recursively add nested objects
        addNestedObjectsToBuilder(
            classDeclaration,
            objectBuilder,
            fieldGenerators,
            fieldTypeExtractor,
            objectFieldRegistry,
        )
    }

    private fun registerObjectField(
        classDeclaration: KSClassDeclaration,
        documentClass: KSClassDeclaration?,
    ) {
        val targetPackage = classDeclaration.packageName.asString()

        if (codeGenUtils.isStandardLibraryType(targetPackage)) {
            return
        }

        val className = generateUniqueQClassName(classDeclaration)
        val objectFieldKey = generateObjectFieldKey(classDeclaration)

        val parentDocumentClass =
            if (documentClass != null && isActuallyNestedClass(classDeclaration, documentClass)) {
                documentClass
            } else {
                isNestedWithinAnyQClass(classDeclaration)
            }

        globalObjectFields[objectFieldKey] =
            ObjectFieldInfo(
                className = className,
                packageName = targetPackage,
                classDeclaration = classDeclaration,
                qualifiedName = classDeclaration.qualifiedName?.asString() ?: classDeclaration.simpleName.asString(),
                parentDocumentClass = parentDocumentClass,
            )
    }

    private fun collectNestedClasses(
        parentClass: KSClassDeclaration,
        allClasses: MutableList<KSClassDeclaration>,
    ) {
        parentClass.declarations.filterIsInstance<KSClassDeclaration>().forEach { nestedClass ->
            if (nestedClass.classKind == ClassKind.CLASS) {
                allClasses.add(nestedClass)
                collectNestedClasses(nestedClass, allClasses)
            }
        }
    }

    private fun collectObjectFieldsFromClass(
        classDeclaration: KSClassDeclaration,
        fieldTypeExtractor: FieldTypeExtractor,
    ) {
        processClassProperties(classDeclaration, fieldTypeExtractor) { nestedClass ->
            val objectFieldKey = generateObjectFieldKey(nestedClass)
            if (objectFieldKey !in globalObjectFields) {
                registerObjectField(nestedClass, null)
                collectObjectFieldsFromClass(nestedClass, fieldTypeExtractor)
            }
        }
    }

    private fun generateUniqueQClassName(classDeclaration: KSClassDeclaration): String {
        val simpleName = classDeclaration.simpleName.asString()
        val parentClass = classDeclaration.parentDeclaration as? KSClassDeclaration

        return if (parentClass != null) {
            "Q${parentClass.simpleName.asString()}$simpleName"
        } else {
            "Q$simpleName"
        }
    }

    private fun generateObjectFieldKey(classDeclaration: KSClassDeclaration): String =
        classDeclaration.qualifiedName?.asString() ?: classDeclaration.simpleName.asString()

    private fun isActuallyNestedClass(
        nestedClass: KSClassDeclaration,
        parentClass: KSClassDeclaration?,
    ): Boolean {
        if (parentClass == null) return false

        return parentClass.declarations.filterIsInstance<KSClassDeclaration>().any {
            it.qualifiedName?.asString() == nestedClass.qualifiedName?.asString()
        }
    }

    private fun isNestedWithinAnyQClass(classDeclaration: KSClassDeclaration): KSClassDeclaration? {
        var parentClass = classDeclaration.parentDeclaration
        while (parentClass != null) {
            if (parentClass is KSClassDeclaration) {
                val hasDocumentAnnotation =
                    parentClass.annotations.any { annotation ->
                        annotation.annotationType
                            .resolve()
                            .declaration.qualifiedName
                            ?.asString() == Document::class.qualifiedName
                    }
                val hasFieldAnnotations =
                    parentClass.getAllProperties().any { property ->
                        val fieldAnnotation = property.findAnnotation(Field::class)
                        val idAnnotation = property.findAnnotation(Id::class)
                        fieldAnnotation != null || idAnnotation != null
                    }
                if (hasDocumentAnnotation || hasFieldAnnotations) {
                    return parentClass
                }
            }
            parentClass = parentClass.parentDeclaration
        }
        return null
    }

    fun getGlobalObjectFields(): Map<String, ObjectFieldInfo> = globalObjectFields.toMap()

    /**
     * Common helper to process properties of a class and extract object/nested fields.
     */
    private fun processClassProperties(
        classDeclaration: KSClassDeclaration,
        fieldTypeExtractor: FieldTypeExtractor,
        onNestedClassFound: (KSClassDeclaration) -> Unit,
    ) {
        classDeclaration.getAllProperties().forEach { property ->
            val fieldAnnotation = property.findAnnotation(Field::class)
            val idAnnotation = property.findAnnotation(Id::class)

            if (fieldAnnotation == null && idAnnotation == null) {
                return@forEach
            }

            val fieldType = fieldTypeExtractor.determineFieldType(property, fieldAnnotation, idAnnotation)

            if (fieldType.isObjectType) {
                val nestedClass = extractNestedClassFromProperty(property)
                if (nestedClass != null) {
                    onNestedClassFound(nestedClass)
                }
            }
        }
    }

    /**
     * Extracts nested class from property, handling both collections and direct object types.
     */
    private fun extractNestedClassFromProperty(property: KSPropertyDeclaration): KSClassDeclaration? =
        if (codeGenUtils.isCollectionType(codeGenUtils.getSimpleTypeName(property.type))) {
            codeGenUtils.getCollectionElementType(property)
        } else {
            property.type.resolve().declaration as? KSClassDeclaration
        }

    /**
     * Processes unique properties of a class to avoid duplicates.
     */
    private fun processUniqueProperties(
        classDeclaration: KSClassDeclaration,
        onProperty: (KSPropertyDeclaration) -> Unit,
    ) {
        val processedPropertyNames = mutableSetOf<String>()
        classDeclaration.getAllProperties().forEach { property ->
            val propertyName = property.simpleName.asString()
            if (propertyName !in processedPropertyNames) {
                onProperty(property)
                processedPropertyNames.add(propertyName)
            }
        }
    }

    /**
     * Checks if a class has any Elasticsearch annotations.
     */
    private fun hasElasticsearchAnnotations(classDeclaration: KSClassDeclaration): Boolean =
        classDeclaration.getAllProperties().any { property ->
            val hasField = property.findAnnotation(Field::class) != null
            val hasId = property.findAnnotation(Id::class) != null
            val hasMultiField = property.findAnnotation(MultiField::class) != null
            hasField || hasId || hasMultiField
        }

    // Extension function to find annotations
    private fun KSPropertyDeclaration.findAnnotation(annotationClass: kotlin.reflect.KClass<*>): KSAnnotation? =
        annotations.find {
            it.annotationType
                .resolve()
                .declaration.qualifiedName
                ?.asString() == annotationClass.qualifiedName
        }
}
